'Assembler' é o nome dado ao programa que gera o arquivo binario apartir de um código 'Assembly'.

'AUTÔMATO'
1. máquina ou engenho composto de mecanismo que lhe imprime determinados movimentos (p.ex., um relógio, certos tipos de brinquedo etc.).
2. aparelho com aparência humana, ou de outros seres animados, que reproduz seus movimentos por meios mecânicos ou eletrônicos.

'Internet das coisas'
A Internet das coisas (inglês: Internet of Things) é, em certa medida, fruto do trabalho desenvolvido pelo MIT Auto-ID Laboratory, recorrendo 
ao uso do 'RFID' e Wireless Sensor Networks. O objetivo foi, desde o início, criar um sistema global de registro de bens usando um sistema de 
numeração único chamado Electronic Product Code. A Internet das coisas é uma revolução tecnológica que representa o futuro da computação e da 
comunicação e cujo desenvolvimento depende da inovação técnica dinâmica em campos tão importantes como os sensores wireless e a nanotecnologia. 
Primeiro, para ligar os objetos e aparelhos do dia-a-dia a grandes bases de dados e redes e à rede das redes, a Internet, é necessário um 
sistema eficiente de identificação. Só desta forma se torna possível coligir e registrar os dados sobre cada uma das coisas. A identificação por
rádio frequência RFID oferece esta funcionalidade.

Identificação por radiofrequência ou RFID (do inglês "Radio-Frequency IDentification" ) é um método de identificação automática através de 
sinais de rádio, recuperando e armazenando dados remotamente através de dispositivos denominados etiquetas RFID. Uma etiqueta ou tag RFID é um 
transponder, pequeno objeto que pode ser colocado em uma pessoa, animal, equipamento, embalagem ou produto, dentre outros. Contém chips de 
silício e antenas que lhe permite responder aos sinais de rádio enviados por uma base transmissora.

Nano-circuitos são a realidade na atual tecnologia CMOS
CMOS (pronuncia-se 'Cí-Mós') é uma sigla para complementary metal-oxide-semiconductor, i.e., semicondutor metal-óxido complementar. É um tipo 
de tecnologia empregada na fabricação de circuitos integrados onde se incluem elementos de lógica digital (portas lógicas, flip-flops, 
contadores, decodificadores, etc.), microprocessadores, microcontroladores, memórias RAM, etc. A tecnologia do CMOS é também utilizada para
produção de circuitos analógicos como sensores de imagem, conversores de sinal e transceptores, utilizados largamente na comunicação. O CMOS 
foi patenteado em 1963 por Frank Wanlass.

O "complementary", em seu nome, vem do fato de que esta tecnologia recente utiliza os dois tipos de transistores MOSFET, o MOSFET canal N e
o MOSFET canal P, de tal modo que um deles "complementa" o outro na necessidade de se produzir funções lógicas.

A 'CMOS' é hoje a tecnologia mais largamente usada na fabricação de CIs. As principais vantagens dos circuitos integrados CMOS são o baixíssimo 
consumo de energia (que leva à baixa dissipação de calor) e a possibilidade de alta densidade de integração, comparativamente com outras
tecnologias como a TTL. Outro importante destaque é a boa relação sinal-ruído devido pelo baixa interferência dos sinais eletrônicos. Devido a
tais características, circuitos CMOS são também largamente utilizados em calculadoras, relógios digitais, e outros dispositivos alimentados por 
pequenas baterias, bem como uma importante opção para tradutores de sinais luminosos. CMOS é a abreviação de "Complementary Metal Oxide "
"Semiconductor". O CMOS é uma pequena área de memória volátil, alimentada por uma bateria, que é usada para gravar as configurações do Setup da 
placa mãe. Como elas (as configurações) representam um pequeno volume de informações, ele é bem pequeno em capacidade. Assim como a memória RAM 
principal, ele é volátil, de forma que as configurações são perdidas quando a alimentação elétrica é cortada. Por isso, toda placa-mãe inclui uma
bateria, que mantém as configurações quando o micro é desligado. A mesma bateria alimenta também o relógio de tempo real (real time clock), que,
apesar do nome pomposo, é um relógio digital comum, que é o responsável por manter atualizada a hora do sistema, mesmo quando o micro é desligado.

Cálculos por segundo
Mechanical -> Electro-mechanical -> Vacuum Tube -> Discrete Transistor -> Integrated Circuit -> Nanotechnology

Principal Componente: Microprocessador
MIPS R2000

MIPS é uma arquitetura de microprocessadores RISC desenvolvido pela MIPS Computer Systems.
Em meados de 1990s estimou-se que um em cada três microprocessadores RISC era MIPS.
Os processadores MIPS são usados em aplicações tais como:
	Computadores da Silicon Graphics;
	muitos sistemas embarcados;
	Dispositivos com Windows CE;
	Roteadores da Cisco
	Videogames como Nintendo 64 e PlayStation.

1.Apresentação e Motivação
	
Arquitetura do conjunto de instruções + Organização da máquina

'Chip'
- Pastilha de silício na qual um
- circuito integrado é implantado
- Área típica de alguns milímetros quadrados
- Contém atualmente bilhões de transistores

'Circuito Integrado'
- Sistema eletrônico que implementa determinada funcionalidade, estampado em silício
- Processadores, memórias, controladores, amplificadores, etc

'Dispositivos Integrados'
- Transistores
- Camadas de Interconexão
	¨Cobre e Tunsgênio
- Polisilício
- Difusão
- Silício - substrato

'Encapsulamentos:'	soldagem
PGA: Pin Grid Array (pininhos)
BGA: Ball Grid Array (bolinhas)
DIP: Dual in-line Package (os CIs de SD1)

Pin Grid Array, PGA frequentemente abreviada, é um tipo de embalagem de circuito integrado. Numa PGA, o pacote é quadrada ou rectangular, e os 
pinos estão dispostos numa matriz regular na parte inferior da embalagem. Os pinos são normalmente espaçadas 2,54 milímetros (0,1 ') entre si, e 
pode ou pode não cobrir toda a parte inferior da embalagem. PGAs são muitas vezes montados em placas de circuito impresso, utilizando o método 
através do furo ou inserido num socket. PGAs permitir mais pinos por circuito integrado de pacotes mais antigos, como Dual In-Line Package (DIP).

Ball Grid Array (BGA) é um tipo de encapsulamento utilizado em circuitos integrados, como por exemplo, chipsets, memórias e microprocessadores. 
A conexão entre o circuito integrado e a placa é feita por pequenos pontos de solda na sua parte inferior, que estão em contato direto com o chip
de silício, dispensando pinos externos como em outros encapsulamentos. É um tipo de encapsulamento onde os terminais de contato são do tipo 
esfera. As medidas mais comuns de esferas utilizadas em chipsets de placas-mãe de PCs ou notebooks são: 0,5, 0,6 e 0,76 milímetros. Tal
componente é inserido ou removido de uma placa de circuito impresso utilizando uma ferramenta denominada Estação de Retrabalho Infrared. Após 
a remoção desse componente, é necessário, para sua reutilização, a colocação de novas esferas através de moldes denominados stencils. Uma das 
características do encapsulamento do tipo BGA é a grande quantidade de pinos, na ordem das centenas, possibilitando a criação de circuitos 
integrados com muitos I/Os. Frequentemente encontrado em FPGAs, chipsets e memórias, uma de suas vantagens é a eliminação dos fios de ouro
utilizados para a conexão ao leadframe, reduzindo problemas com capacitância e indutância indesejadas em circuitos que trabalham em altas 
frequências.

Dual In-Line Package (abreviado "DIP" ou "DIL") é um tipo de encapsulamento de circuitos integrados. Suas principais características são o 
invólucro plástico ou metálico e duas fileiras de pinos em lados opostos do CI, normalmente em seu lado maior. Um exemplo comum é o CI 555.Um 
dos primeiros tipos de encapsulamento de memórias, popular nas épocas dos computadores XT e 286. seu encaixe ou mesmo sua colagem através de 
solda em placas pode ser feita facilmente de forma manual.

'Decimal x Binário'
kilobyte = 10^3
kibibyte = 2^10

'Classes de Computadores'

'Computadores pessoais'
- propósito geral, variedade de software
- sujeitos a uma relação custo/desempenho
	¨alguns gigabytes de RAM (gibibytes), 500 GB a 1 TB de disco
	¨introdução de SSD (Solid State Drive - disco em estado sólido)
'Servidores'
- interconectados em rede
- alta capacidade, desempenho e confiabilidade
- abrange desde pequenos servidores (um desktop) até sistemas para altas capacidades de armazenamento e vazão de dados (data centers)

'Supercomputadores'
- aplicações científicas e cálculos de engenharia de altíssimo desempenho
- milhares de processadores interligados por conexões de alta velocidade, com terabytes (tebibytes) de memória
- pequena fração do mercado

'Computadores embarcados'
- componentes embutidos, fazem parte de sistemas mais complexos
- restrições de recursos e desempenho
- dominam o mercado, maior taxa de crescimento

'Pós-PC' Tablet
tela sensível ao toque
integra monitor, teclado e mouse em um único dispositivo
	-> tela capacitiva:
	  - permite multiplos toques simultâneos
	  - dominante no mercado
	
2. Introdução, Abstrações e Histórico

'O que é: Organização e Arquitetura de Computadores?'
- Arquitetura do conjunto de instruções + Organização da máquina

'O que é um computador?'
-> Componentes:
 - Processador(es)
 - Dispositivos de entrada (mouse, teclado,...)
 - Dispositivos de saída (monitor, impressora,...)
 - Dispositivos de memória (DRAM, SRAM, HD, CD, DVD,...)
 - Dispositivos de comunicação (Ethernet, USB, IEEE1394, ...)
 
-> Nosso foco principal: o processador (caminho de dados e controle)
 - Implementado usando milhões de transistores
 - Impossível de entender olhando para os transistores
 - O processador manipula a memória, e dela temos entrada e saída de dados.
 
- Estrutura:: programa em alto nível (C) -> COMPILADOR -> programa em assembly (MIPS) -> MONTADOR -> 1s e 0s linguagem de máquina (MIPS)

'Abstração'
- Maior aprofundamento revela mais informações
- Uma abstração omite detalhes desnecessários e ajuda a entender sistemas complexos
- É a descrição simplificada ou seletiva de um sistema

'Como os computadores funcionam?'
-> É preciso entender abstrações como:
  - Software de Aplicação (usuário)
  - Software Básico (ou de sistema) (SO, drivers, etc)
  - Linguagem de montagem (Assembly)
  - Linguagem de máquina (0101010011010011)
  - Aspectos da organização da máquina (processador, memórias, etc)
  - Lógica sequencial, máquinas de estado finito
  - Lógica combinatória, circuitos aritméticos, portas lógicas
  - Lógica booleana, 1s e 0s
  - Transistores usados para construir portas lógicas (CMOS/TTL)
  - Física dos semicondutores
  - Propriedades dos átomos e moléculas
  - Mecânica quântica
  
'Arquitetura do Conjunto de Instruções (ISA)' 
-O ISA inclui o modelo de execução, registradores do processador, endereço e formatos de dados, entre outras coisas.
-> Uma abstração muito importante:
  - interface entre o hardware e o software de baixo nível 
  - padroniza instruções, padrões de bits de linguagem de máquina, etc.
  - vantagem: 	 permite diferentes implementações de uma arquitetura.
  - desvantagem: algumas vezes impede o uso de inovações. 
-> Arquiteturas de conjunto de instruções modernas: IA-32 (x86), EM64T, PowerPC, SGI, MIPS, 'Computadores da Silicon Graphics;
											    'muitos sistemas embarcados;
											    'Dispositivos com Windows CE;
											    'Roteadores da Cisco
											    'Videogames como Nintendo 64 e PlayStation.'
						    SUN SPARC, ARM 'arquitetura de proces. 32 bits principalmente de sistemas embarcados,
								   'e celulares',
						    HP PA-RISC e outras
'Arquitetura x Organização x Implementação'
- Arquitetura: Conjunto de instruções de definição e compatibilidade.
- Organização (microarquitetura): Implementação do hardware mantendo instruções compatíveis com a arquitetura alto-nível.
- Implementação (processadores): implementação produtizada da microarquitetura.

'Máquina de Babbage introduz organização usada até hoje'
-armazenamento
-engenho
-controle
- COMANDOS -> MEMÓRIA -> CONTROLE -> MEMÓRIA <- DADOS

'O MARK I - Arquitetura Harvard'
-> Os dados eram armazenados em local diferente das instruções (programa)
  - Programa: Papel perfurado
  - Dados: Dispositivos Eletromecânicos
- As instruções também eram armazenadas num formato diferente dos dados.
- A técnica de armazenamento de dados e instruções separadamente tornou-se conhecida como Arquitetura Harvard.

'ENIAC - 1º Computador Eletrônico'
- No início dos anos 40 este computador foi desenvolvido na Universidade da Pennsylvania, utilizando 18000 válvulas e 1500  relés  para  
movimentar  a  informação  através  da máquina, chamado de Electronic Numerical Integrator And Calculator. 
- Podia   fazer   5000   adições   por   segundo   ou   357 multiplicações por segundo.
- Era  programado  por  cartões  perfurados  e  podia  ler  dois números por segundo.
- Segunda Guerra Mundial: calcular tabelas de disparo de artilharia, era gigante(20 registradores de 10 dígitos com 60cm cada).

'A arquitetura von Neumann'
- John von Neumann mostrou que as instruções poderiam ser representadas na mesma linguagem utilizada para os dados.
- Instruções e dados poderiam, então, ser armazenados 'juntos dentro do computador'.
- Num típico sistema von Neumann, 'instruções e dados estão inseridos juntos na mesma memória'. 
- Muitas vezes com os dados seguindo imediatamente as instruções.
- Instruções são apenas números, não podendo ser distinguidas dos dados.
- A arquitetura von Neumann e o 'conceito de programa armazenado' tornou-se padrão para os sistemas computacionais.

Combinar instruções e dados na mesma memória traz algumas vantagens:
-> Uso eficiente da memória. 
  - Um único bloco (grande) de memória ao invés de dois menores.
-> Instruções são facilmente manipuláveis (como os dados).
  - Como  instruções  e  dados  estão  armazenados juntos,   movimentar   blocos   de   instruções (programas) é mais simples, ou ...
-> Facilidade em carregar programas na memória.
  - Basta ler as instruções do disco ou outra memória secundária e executá-las.
  
Combinar instruções e dados na mesma memória traz algumas desvantagens:
-> 'Dados podem sobrescrever instruções': Sem  alguma  precaução  especial  do  hardware (proteção  de  memória), uma  escrita  incorreta  na 
memória pode sobrescrever algumas instruções. Como  os  sistemas  von  Neumann  não  fazem distinção  entre  dados  e  instruções,  a  máquina 
pode  tentar  executar  dados  como  instruções, com resultados imprevisíveis.
-> 'Largura de banda limitada': Armazenar  instruções  e  dados  juntos  significa que  ambos  percorrem  o  mesmo  caminho  até  o processador. 
Este é o 'gargalo da arquitetura von Neumann'. O processador  deve  executar  um  grande  número de  instruções  por  segundo  e  ler  uma  
grande quantidade de dados ao mesmo tempo.

'Mudanças no hardware'
- No final dos anos 50 foi introduzido o uso do transistor. 1/200 do tamanho da válvula.
- Geravam muito menos calor que as válvulas e eram muito, muito mais rápidos(as distâncias eram muito menores): podiam suportar até 100.000 
chaveamentos por segundo.

'Revolução da Eletrônica'
- Válvulas -> Transistores -> Circuitos Integrados -> SSI -> MSI -> LSI -> VLSI -> ULSI (ultra-large-scale)

- Conceitos de organização, paralelismo e hierarquia de memória são os mesmos de mainframes das décadas de 60 e 70
-> diferença está na tecnologia
  - 1970: poucos milhares de transistores num chip
  - 2005: centenas de milhões de transistores num chip
  - 2010: mais de 2 bilhões de transistores num chip

- 1971: Intel 4004 - 4 bits, 2.300 transistores, 740kHz
- 1972: Intel 8008 - 8 bits, 3.500, 500kHz
- 1976, Intel 8085 - 8 bits, 6.500, 5MHz
- 1978: Intel 8086 - 16 bits, 29.000, 10MHz
- 1982: Intel 80186 - 16 bits
- 1982: Intel 80286 - 16 bits, 134.000, 25MHz
- 1985: Intel 80386 - 32 bits, 275.000, 33MHz (cache externa)
- 1989: Intel 40486 - 32 bits, 1.200.000, 50MHz (L1 cache)
- 1993: Pentium - 32 bits, 3.100.000, até 233MHz
- 1995: Pentium Pro e MMX - 32 bits, 4.500.000, 200MHz (L2 cache)
- 1997: Pentium II- 32 bits, 7.5000.000, 450MHz
- 1999: Pentium III - 32 bits, 28.000.000, 1.13GHz 
- 2000: Pentium IV - 32 bits, 42.000.000, até 3.4GHz
- 2001: Intel Itanium - 64 bits (AMD antes)
- 2003: Pentium-M (Centrino, Celeron M) - 32 bits, 77.000.000, 2.1GHz
- 2005: Pentium-D (Extreme HT) - 64 bits, 230.000.000, 3.4GHz
- 2006: Core (Duo,Solo) - 32 bits, 151.000.000, 1.66GHz
- 2006: Core2 (Duo) -  64 bits, 291.000.000, 3GHz
- 2007: Core2 (Quad) - 64 bits 830.000.000 3GHz (só L2)
- 2008: Core i7 (Quad) - 64 bits 731.000.000 3GHz (L3 cache)
- 2011: Core i7 (Hexa) - 64 bits 2.700.000 3,3 - 3,9GHz 

'A Arquitetura Harvard Modificada'
- A arquitetura Von Neumann tornou-se muito popular, porém as suas limitações(principalmente o gargalo de Von Neumann) pareciam insuperáveis.
- O avanço da microeletrônica (barateamento dos dispositivos de memória) e a popularização do conceito de hierarquia de memória, trouxe a 
arquitetura Harvard de volta.
- A Arquitetura Harvard Modificada é atualmente utilizada em praticamente todos os sistemas computacionais.

'A Arquitetura Harvard Original'
- O   retorno   da   arquitetura   Harvard   foi   impulsionada inicialmente  pelos  Processadores  Digitais  de  Sinais,  e utilizada  ainda 
hoje,  na  sua  forma  pura,  em  diversos processadores  e  microcontroladores  de  baixo  custo. 
Ex.: DSPs, microcontroladores PIC, 8051, etc.

'A Arquitetura Harvard Modificada'
- A Arquitetura  Harvard  Modificada  é  atualmente  utilizada  em  praticamente todos os sistemas computacionais. 
- Une  os  benefícios  da  maior  largura  de  banda  (acesso  a  instruções  e dados simultaneamente) com o conceito de programa armazenado.

*obs: cada processador contido no wafer é chamado de die.

'Intel Roadmap'
- Tick: Avanço na tecnologia de integração (tamanho)
- Tock: Nova Microarquitetura (Organização)
 

3. Arquitetura MIPS

'ISA MIPS (Instruction Set Architecture)'
- MIPS é uma arquitetura de microprocessadores RISC
-> Vamos trabalhar com a arquitetura do conjunto de instruções MIPS
  - Semelhante a outras arquiteturas desenvolvidas desde a década de 1980
  - Mais de 350 milhões de processadores MIPS fabricados em 2009
  - Usada pela NEC, Nintendo, Cisco, Silicon Graphics, Sony...
  - MIPS 32 e 64 bits incrementados (3D,DSP,etc)!
  
'Tradutores'
- Montadores, Compiladores e Interpretadores.

'ISA do MIPS (simplificada)'
-> Categorias de Instruções:
  - Load/Store
  - Computação
  - Jump e Desvio
  - Ponto Flutuante
  - Gerenciamento de Memória
  - Especial
  
-> Registradores: |R0-R31|PC|HI|LO| 

-> 3 Formatos de Instrução: 32 bits
  - 1) OP|rs|rt|rd|sa|funct|
  - 2) OP|rs|rt|  imediato |  
  - 3) OP| destino do jump |
  
'Operações do Hardware'
-> Todo computador deve ser capaz de realizar operações aritméticas.
  - ex..:    add   a,b,c -> a = b + c
-> Instruções aritméticas no MIPS têm formato fixo, realizando somente uma operação e tendo três "variáveis"
  - ex: a = b + c + d + e
	
	add a, b, c	# a = b + c	--comentários são declarados assim
	add a, a, d	# a = b + c + d
	add a, a, e	# a = b + c + d + e
#usa-se somente uma instrução por linha.

- Exigir que toda instrução tenha exatamente três operandos condiz com a filosofia de manter o hardware simples: hardware para número variável 
de parâmetros é mais complexo que para número fixo.
#Princípio #1 para projetos: Simplicidade favorece a regularidade

ex1: Em C
    a = b + c;
    d = a - e;
    
     Gerado pelo compilador
    add a, b, c		# a = b + c
    sub d, a, e		# d = a - e
    
ex2: Em C
    f = (g + h) - (i + j);
    'Somente uma operação é feita por instrução: necessidade  de variáveis temporárias.'
    
     Gerado pelo compilador
    add t0, g, h	# temporário t0 = g + h
    add t1, i, j	# temporário t1 = i + j
    sub f, t0, t1	#f = (g + h) - (i + j);
    
'Operandos e Registradores'
- Registradores do MIPS são de 32 bits;
- no MIPS, blocos de 32 bits são chamados de palavra;
-> Número de registradores é limitado: MIPS - 32 registradores, numerados de 0 a 31
    - acesso mais rápido, interno ao chip
    - fácil acesso 
    
-> Princípio #2 para projetos: menor é mais rápido
  - Um número muito grande de registradores aumentaria o período de clock.
  
-> No MIPS existe uma convenção para nomear registradores na forma $xi:
    - $s0, $s1, $s2,... para registradores que correspondam a variáveis em C
    - $t0, $t1, $t2,... para registradores temporários necessários para compilar o programa em instruções MIPS
    
->Considerando a convenção adotada, podemos associar:
    - f => $s0
    - g => $s1
    - h => $s2
    - i => $s3
    - j => $s4
    
    e fazer...
    add  $t0,$s1,$s2		# temporário t0 = g + h
    add  $t1,$s3,$s4		# temporário t1 = i + j
    sub  $s0,$t0,$t1		# f = (g + h) - (i + j);
    
'Registradores vs. Memória'
- Operandos de instruções aritméticas devem ser registradores (32 registradores disponíveis).
- Compilador associa variáveis a registradores.
- E programas com várias variáveis?
    
'Organização da Memória'
- Vista como um grande array unidimensional, com endereços seqüenciais, começando em 0
- Um endereço de memória é um índice no array.
- "Byte addressing" significa que o índice aponta para um byte na memória.
- As palavras de 32 bits são divididas em 4 bytes
- O MIPS pode endereçar um byte ou uma palavra inteira
- Instrução define se é byte ou word
  -> 2^32 bytes com endereços de byte de 0, 1, 2, 3, ... 2^32 -1
  -> 2^30 words com endereços de byte de 0, 4, 8, ... 2^32 -4
- Words são alinhadas, i.e., quais são os valores dos 2 bits menossignificativos do endereço de uma word?
    
'Ordenamento dos Bytes'
-> Processadores podem numerar bytes dentro de uma palavra, de tal forma que o byte com o menor número é o mais a esquerda ou o mais a 
direita. Isto é chamado de byte order.
     Ex: .byte 0, 1, 2, 3
     - big endian 	0|1|2|3
     - little endian	3|2|1|0
     
     - Big endian: IBM 360/370, Motorola 68k, MIPS, Sparc, HP, PA
     - Little Endian: Intel 80x86, MIPS, DEC Vax, DEC Alpha
     
'Transferindo dados da memória'
-> A instrução de transferência de dados da memória para o registrador é chamada de load.
    'No MIPS, o nome da instrução é: lw (load word)'
-> Formato:
    lw registrador destino, constante (registrador base)
-> Ex: g = h + *a;

    a => s3, g => s1, h => s2
    
    lw       $t0,  0($s3)         # temporário t0 = *a     //0($s3) = significa conteúdo de s3 no offset 0.
    add      $s1, $s2, $t0        # g = h + *a
    
'Vetor na Memória'
- Vetor A = [0,0,0,0,15], com 5 posições, começando no endereço de memória 102.  Este endereço é chamado de endereço base do vetor. Assim, 102 
é o endereço de A[0],103 o de A[1], ...,106 o de A[4].

'Vetor de words'
- Cada posição do vetor (de inteiros) é uma palavra, e portanto ocupa 4 bytes
- Vetor A = [0,0,0,0,15], com 5 posições, começando no endereço de memória 408. Assim, 408 é o endereço de A[0],412 o de A[1], 416 o de A[2],
420 o de A[3] e 424 o de A[4].

	A[12] = h + A[8] ?
	
	lw  $t0, 32($s3)     #temporário t0 = A[8]			 
	add $t0, $s2, $t0    #temporário t0 = h + A[8]		 
	sw $t0, 48($s3)      #carrega A[12] em $t0

'Transferindo dados para a memória'	
-> A instrução de transferência de dados de um registrador para a memória é chamada de store.
	- No MIPS, o nome da instrução é: sw (store word)
-> Formato:
	- sw registrador fonte, constante (registrador base/destino)
-> Endereço de memória acessado é dado pela soma da constante (offset) com o conteúdo do registrador base.

'Organização dos processadores MIPS'
-> Convenção do uso dos Registradores
	- O registrador $0 contém sempre o valor 0 (hardwired)
	- Os registradores $1  ($at), $26 ($k0) e $27 ($k1 ) são reservados para uso do montador e sistema operacional.
	- Os registradores $2 e $3 ($v0, $v1 ) são utilizados para retornar valores de funções.
	- Os registradores $4 ... $7 ($a0 ... $a3) são utilizados para passagem dos primeiros quatro argumentos para subprogramas (os argumentos
	restantes são passados através da pilha).
	- Os registradores $4 ... $7 ($a0 ... $a3) são utilizados para passagem dos primeiros quatro argumentos para subprogramas (os argumentos
	restantes são passados através da pilha).
	- Os registradores $8...$15, $24, $25 ($t0...$t9) são callersaved para dados temporários que não necessitam ser preservados durante 
	as chamadas.
	- Os registradores $16...$23 ($s0...$s7) são callee-saved para dados que necessitam ser preservados durante as chamadas.
	- O registrador $28 ($gp) é um ponteiro global que aponta para o meio de um bloco de memória de 64K, no segmento de dados estáticos.
	- O registrador $29 ($sp) é o ponteiro de pilha,apontando sempre para o primeiro elemento da pilha.
	- O registrador $30 ($fp) é o ponteiro de frame. Pode ser utilizado como registrador callee-saved $s8.
	- O registrador $31  ($ra) armazena o endereço de retorno quando é executada a instrução jal.
	
4. Assembly MIPS

'MIPS'
- Banco de 32 registradores de 32 bits cada
- lw Carrega words mas endereça bytes na memória
- Aritmética somente entre registradores ou imediato

'Instrução'		 		'Significado'
add $s1, $s2, $s3 		$s1 = $s2 + $s3
sub $s1, $s2, $s3 		$s1 = $s2 – $s3
addi $s1,$s2,imm 		$s1=$s2+imm
muli $s1,$s2,imm 		$s1=$s2×imm (pseudo)
lw $s1, imm($s2) 		$s1 = Memory[$s2+imm]
sw $s1, imm($s2) 		Memory[$s2+imm] = $s1

'Programa armazenado (conceito)'
- Todas as instruções são codificadas em bits.
- Todos os dados são representados em bits.
- Programas são armazenados na memória para serem lidos da mesma forma que os dados.

'Ciclos de busca e execução:'
- Instruções são buscadas e colocadas num registrador especial(IR – Instruction Register).
- Bits deste registrador "controlam" as ações subseqüentes necessárias à execução da instrução.
- Busca a próxima instrução e continua...	
- BUSCA -> DECODIFICAÇÂO -> EXECUÇÂO

'Linguagem de máquina'
No MIPS, as instruções, assim como os registradores, também têm 32 bits de comprimento dividido em campos
|op | rs | rt | rd | shamt | funct |

- op 	6bits 	operação básica da instrução: opcode
- rs 	5bits 	primeiro registrador de operando origem
- rt 	5bits 	segundo registrador de operando origem
- rd 	5bits 	registrador de operando destino: resultado
- shamt 5bits 	deslocamento: shift amount
- funct 6bits 	variação da operação: function code

Exemplo: add $t0, $s1, $s2
- Instrução add: opcode=0 funct=32 (vide guia de referência)
- registradores são identificados por seus números (vide tabelas):
					$t0=8, $s1=17, $s2=18
					
#Formato Tipo-R de instrução:
CAMPO		op		rs		rt		rd		shamt		funct
DECIMAL		0		17		18		8		0		32
BINÁRIO		000000  10001	10010	01000	00000		100000
TAMANHO		6 bits	5 bits	5 bits	5 bits	5 bits		6 bits

- O que acontece quando uma instrução necessita de campos maiores?
Ex.:
	addi $t0,$t1,Imm
	lw $t0,Imm($t1)
	
	4° Princípio de Projeto: Um bom projeto exige bons compromissos.

- Novo tipo de formato de instrução para instruções com dados Imediatos.
Exemplo: lw $t0, 32($s3)

#Formato Tipo-I de instrução:
CAMPO		op		rs		rt		Imm
DECIMAL		35		19		8		32
BINÁRIO		100011  10011	01000	0000000000100000
TAMANHO		6 bits	5 bits	5 bits	16 bits

Obs.: MIPS não tem instrução “subi $t0,$t1,Imm” por que? Só somar com o negativo.

'Exemplo de compilação manual'
- Suponha que $t1 tenha o endereço base de A e que $s2 corresponda a h, traduza a seguinte linha em C para código de máquina MIPS: A[300] = h + A[300];
- Primeiro, temos que o código em assembly correspondente é:


												|   op	 	|	 rs	   |    rt   |	        imediato            |
																				 |  rd     |  shamt  | funct    |
lw $t0,1200($t1) 		# $t0 = A[300]			|35(100011)	|9 (01001) |8(01000) |1200(0000 0100 1011 0000)		|
add $t0, $s2, $t0 		# $t0 = h + A[300]		|0 (000000) |18(10010) |8(01000) |8(01000) |0(00000) |32(100000)|
sw $t0, 1200($t1) 		# A[300] = h + A[300]	|43(101011) |9 (01001) |8(01000) |1200(0000 0100 1011 0000)		|
- Qual o código de máquina destas 3 instruções?

Na memória  - Endereço anda de 4 em 4 bytes..(8bits * 4 = 32bits = tamanho de cada instrução)
			- Cada número do código ASCII = 4bits (como tem 8 por instrução, 4bits * 8 = 32 = tamanho de cada instrução)
												
												0x00400000 8D 28 04 B0
												0x00400004 02 48 40 20
												0x00400008 AD 28 04 B0
												
#Operações Lógicas
OPERAÇÃO			C		INSTRUÇÃO MIPS		OPCODE/FUNCT
Shift à esquerda	<<		sll						 0/0
Shift à direita		>>		srl						 0/2
And					&		and						 0/36
							andi					 12
Or					|		or						 0/37
							ori						 13
Xor					^		xor						 0/38
							xori					 14
Nor							nor						 0/39

#Controle de Fluxo
- Desvio Incondicional
	Registrador Especial PC (Program Counter): indica qual o endereço da próxima instrução a ser buscada na memória

Instruções MIPS:
 jr $t0 		# Jump Register: PC=[$t0] ? Obs.: Tipo-R !
 j Label 		# Jump Label: PC=Label
 jal Label 		# Jump and Link: $'ra'=PC+4; PC=Label		#aqui usa-se ra
 
#Formato Tipo-J de instrução: Ex.: j 1200
op		Endereço
2		1200
000010	00000000000000010010110000								
									
- Desvio Condicional
	
Instruções MIPS de desvio condicional:
bne $t0, $t1, Label 		# Branch if Not Equal: $t0!=$t1 ? PC=Label
beq $t0, $t1, Label 		# Branch if Equal: $t0==$t1 ? PC=Label

Exemplo:
 if (i!=j) 						beq $s4, $s5, Label1
	h=i+j; 						add $s3, $s4, $s5
 else 							j Label2
	h=i-j; 						Label1: sub $s3, $s4, $s5
								Label2: ...

- Implementadas as comparações: == e !=
- Como implementar: <, >, <=, >= ?

Instrução MIPS: Set on Less Than
slt $t0,$t1,$t2 			# $t0=1 se $t1<$t2; $t0=0 caso contrário
slti $t0,$t1,Imm 			# $t0=1 se $t1<Imm; $t0=0 caso contrário

- Apenas com estas instruções podemos montar várias estruturas de controle. Ao montador é reservado o registrador $1 ($at) para essa tarefa.

#Constantes
- Constantes são usadas freqüentemente
	Por exemplo: A = 7283891;
	B = A + 1881729383;
	C = B / 91827261287854;
- Soluções?
	- colocar “constantes” na memória e carregá-las (lw).
	- criar registradores hardwired (como $zero) para constantes como um.
	- colocar as constantes na própria instrução
- Princípio de projeto: agilizar o caso comum.

'Constantes “pequenas”'
- Constantes pequenas são usadas muito freqüentemente (50% dos operandos)
	Por exemplo: A = A + 1;
	- colocar as constantes na própria instrução
	Instruções com imediato MIPS:
	addi $29, $29, 4 	# R[29]=R[29]+4
	slti $8, $20, 10 	# R[8]=(R[20]<10?1:0)
	andi $29, $29, 6 	# R[29]=R[29] & 6
	ori $29, $29, 4 	# R[29]=R[29] | 4
	
'E constantes maiores?'
- Para carregar uma constante de 32 bit num registrador são necessárias duas instruções.
	- Nova instrução: Load Upper Immediate
	lui $t0, 1010101010101010		#carrega os primeiros 16 bits com o valor do parâmetro e preenche o resto com 0's.
	ori $t0, $t0, 1010101010101010	#preenche os 16 bits menos significativos usando OR imediato.
	
'Resumo do MIPS'
- Instruções simples, todas de 32 bits
- Bastante estruturada
- Somente três formatos de instruções (inteiros) -> R,I,J 

'Endereços em desvios'
- Instruções:
	bne $t4, $t5, Label 	# Próxima instrução em Label se $t4 ? $t5
	beq $t4, $t5, Label  	# Próxima instrução em Label se $t4 = $t5
	j Label 				# Próxima instrução em Label
	jal Label 				# $ra=PC+4; Próxima Instrução em Label
	
	Em I => Imm = 16 bits
	Em J => Endereço = 26 bits
	#OPS!!!! Endereços não têm 32 bits!!!

- Instruções tipo-I, beq e bne, usam Endereço Relativo '#SOMA PC'
	- maioria dos desvios condicionais são locais (Princípio da Localidade)
	- utilizar Program Counter(PC)
		'PC = (PC+4)+ExtSinal[Imm]<<2'
		
- Instruções tipo-J, j e jal , utilizam os 4 bits mais significativos do PC e concatenam ao Endereço deslocado 2 bits à esquerda. '#CONCATENA PC'
	'PC = { (PC+4)[31-28] , (Endereço<<2) }'
	- limites de endereçamento de 256 MB (64M instruções).	
	- O montador e o ligador precisam cuidar disso!
	#SLIDE 22 É IMPORTANTE
	
Exemplo: while(save[i]==k) i++;
Loop: sll $t1,$s3,2
 add $t1,$t1,$s6
 lw $t0,0($t1)
 bne $t0,$s5, Exit
 addi $s3,$s3,1
 j Loop
Exit:
    
O que aconteceria se imm=-1? LOOP INFINITO
#PC prox = End*4 + PC(sucessor)

'Linguagem Assembly vs. linguagem de máquina'
- O assembly fornece uma representação simbólica conveniente
 - muito mais fácil do que escrever números binários
 - por exemplo, destino primeiro
	- Pode-se usar Labels ao invés de endereços numéricos
- A linguagem de máquina é realidade subjacente
 - por exemplo, o destino não é mais o primeiro
 - Labels são convertidos em números apropriados
- O assembly pode fornecer “pseudo-instruções”
 - por exemplo, “move $t0, $t1” existe apenas no assembly
 - podendo ser implementada usando “add $t0,$t1,$zero”
- Ao considerar o desempenho, você deve contar as instruções reais    

#Assembly MIPS Procedimentos
- No MIPS, os dados precisam estar em registradores para a realização de operações aritméticas.
- O registrador $at é reservado para o montador.
- Categoria de instruções: 
	-> Aritmética
	-> Tranferência de dados
	-> Desvio Condicional
	-> Devio incondicional

- Instruções de suporte a procedimentos
	-> Passos em um procedimento:
1. Colocar os parâmetros em um lugar onde o procedimento possa acessá-los;					//$a0-$a3
2. Transferir o controle para o procedimento;												//$ra; desvio
3. Adquirir recursos de armazenamento necessários para o procedimento;						
4. Realizar a tarefa desejada;
5. Colocar o valor de retorno em um lugar onde o programa que o chamou possa acessá-lo;		//$v0-$v1
6. Retornar o controle para o ponto de origem.												//jr $ra		

	-> Qual o lugar mais rápido que pode armazenar dados em um computador?
	- Registradores MIPS:
		- $a0 - $a3: parâmetros para os procedimentos;
		- $v0 - $v1: valores de retorno do procedimento;
		- $ra: registrador de endereço de retorno ao ponto de origem (ra = return address).
		
#jal (jump and link)
- Link, neste caso, quer dizer que é armazenada, no registrador $ra, o endereço da instrução que vem logo após a instrução jal Label:
- Código “equivalente”
			addi $ra, $PC, 4
			j Label

- Usando mais registradores
	- Se precisar mais de 4 argumentos e 2 valores de retorno?.
	- Se o procedimento necessitar utilizar registradores salvos $sx?
'register spilling'
    - Uso de uma pilha;
	- Temos um apontador para o topo da pilha;
	- Este apontador é ajustado em uma palavra para cada registrador que é colocado na pilha ('push'), ou retirado da pilha ('pop').
	- Em MIPS, o registrador 29 é utilizado somente para indicar o topo da pilha: $sp (stack pointer)

#Usando a Pilha
- Por razões históricas, a pilha “cresce” do maior endereço para o menor endereço;
- Para colocar um valor na pilha (push), devemos decrementar $sp em uma palavra e mover o valor desejado para a posição de memória apontada por $sp;
- Para retirar um valor da pilha (pop), devemos ler este valor da posição de memória apontado por $sp, e então incrementar $sp em uma palavra.
- Para armazenar na pilha:
							addi $sp, $sp, -12 # cria espaço para 3 itens na pilha
							sw $t1, 8($sp) # empilha $t1
							sw $t0, 4($sp) # empilha $t0
							sw $s0, 0($sp) # empilha $s0
- Para desempilhar da pilha e restaurar os valores: 
							lw $s0, 0($sp ) # desempilha $s0
							lw $t0, 4($sp) # desempilha $t0
							lw $t1, 8 ($sp) # desempilha $t1
							addi $sp, $sp, 12 # remove 3 itens da pilha
							
- Versão otimizada
	•Salvar o que realmente necessitar ser salvo
	•Por convenção, os registradores $ti não precisam ser preservados.
	•Utilizar registradores $si onde realmente forem necessários.
	•Ponderar uso de registradores com análise de desempenho.

- Procedimentos aninhados
	- Problema: conflito com registradores $a e $ra!
	- Como resolver?
- Convenção sobre registradores
	- Uma solução é empilhar todos os registradores que precisam ser preservados.
	- Estabelecer uma convenção entre subrotinas chamada e chamadora sobre a preservação dos registradores (uso eficiente da pilha).
	- Definições
		• Chamadora: função que faz a chamada, utilizando jal;
		• Chamada: função sendo chamada
		
- Por que utilizar convenções para chamadas de procedimentos?
	- Benefícios:
		- programadores podem escrever funções que funcionam juntas;
	    - Funções que chamam outras funções – como as recursivas – funcionam corretamente

#Assembly MIPS - Recursividade
- Soma_recursiva:
- Para armazenar na pilha:
							addi $sp, $sp, -8 	# prepara a pilha para receber 2 itens
							sw $ra, 4($sp) 		# empilha $ra (End. Retorno)
							sw $a0, 0($sp) 		# empilha $a0 (n)
- Quando queremos recursão, armazenamos o valor do registrador $ra!!
- Na primeira vez que soma_recursiva é chamada, o valor de $ra que é armazenado corresponde ao endereço que está na rotina chamadora
- Para restaurar da pilha: 
							lw $a0, 0($sp) # restaura o valor de n
							lw $ra, 4($sp) # restaura o endereço de retorno
							addi $sp, $sp, 8 # retira 2 itens da pilha
							..
							jr $ra # retorne para a chamadora

- O que “deve” ser preservado em chamadas recursivas?
	- Registradores $s0-$s7
	- Stack Pointer $sp
	- Pilha acima do $sp
	- Registrador de retorno $ra
	- Frame Pointer ($fp)
	- Global Pointer ($gp) se utilizados
- O que não “deve” ser preservado em chamadas recursivas?
	- Registradores $t0-$t9
	- Registradores $a0-$a3
	- Pilha abaixo do $sp
	- Registradores $v0-$v1
	
- Alocando espaço para novos dados locais na pilha
	-> Frame de Procedimento (Registro de Ativação)
		- Armazenar variáveis locais a um procedimento
		- Facilita o acesso a essas variáveis locais ter um apontador estável $fp
	
- Ex.: Alocação de memória (SPIM e MARS)
	- Heap: Espaço explicitamente criado malloc: apontadores em C
	
#Aritmética Inteira (TUDO EM COMPLEMENTO DE 2!!!)
-> Adição e subtração
	- NÃO SEMPRE DESCARTAMOS O CARRY OUT (ELE NÃO TEM NADA A VER COM OVERFLOW)
	- Exatamente como base decimal (emprestar/vai 1s) 'descartando o carry out'
	- Facilidade de operações do complemento de dois - subtração usando adição para números negativos 
	- Overflow (resultado muito grande para a word finita do computador): Somar dois números de n bits pode produzir um número de n+1 bits.
	
	*obs* Note que o termo overflow não significa que um carry simplesmente “transbordou” (n de bits do resultado > n bits das parcelas), 
		  Mas sim que o resultado não “cabe” na faixa dinâmica de n bits!!!
	
#Detectando overflow
!!!!!!- LEMBRANDO QUE DESCARTAMOS O CARRY OUT -!!!!!!
## PRIMEIRA ABORDAGEM ##
	- Nenhum overflow quando: - somar um número positivo com um negativo
							  - subtrair operandos de sinais iguais
	
	- Overflow quando:		  - somar dois positivos e resultar um negativo					//A+B < 0
		(sendo A>0 e B>0)	  - somar dois negativos e resultar um positivo					//A+(-B) > 0
							  - subtrair um negativo de um positivo e resultar um negativo	//A-(-B) < 0
							  - subtrair um positivo de um negativo e resultar um positivo	//-A-B > 0
	
## SEGUNDA ABORDAGEM ##
	- SOMA: 	   - os MSB dos operandos forem diferentes: NÃO HÁ OVERFLOW!
				   - os MSB dos operandos forem iguais e o MSB do resultado for diferente dos operandos: HÁ OVERFLOW!
							
## TERCEIRA ABORDAGEM ##
	- SOMA: 	   - carry in do MSB for diferente do Carry out: HÁ OVERFLOW
	
#Efeitos do overflow
-> Uma exceção (interrupção) ocorre
	- O controle salta para um endereço predefinido para exceção
	- O endereço interrompido é salvo para uma possível retomada
-> Detalhes baseados na linguagem/sistema de software	//Obs.: C versus FORTRAN
	- Nem sempre desejamos detectar overflow — novas instruções MIPS: addu, addiu, subu
	- Nota: addiu ainda com extensão de sinal
	- Nota: sltu, sltiu para comparações sem sinal

- Principais Arquiteturas Aritméticas
	-> Pilha:
		- As operações são sempre realizadas com os argumentos na pilha, e o resultado é também armazenado na pilha. 
		.ex (calculadoras HP, Linguagem Forth, x87(ST0-ST7, 80 bits)
	-> Acumulador:
		- As operações são feitas sobre registradores (incluindo A) e o resultado armazenado em um registrador especial chamado 
		.ex Acumulador (A).(Z80, 8051)
	-> Registrador-Registrador:
		- As operações são feitas sobre registradores e o resultado é armazenado em qualquer registrador. 
		.ex (MIPS, ARM)
	-> Registrador-Memória:
		- As operações aritméticas buscam um dos argumentos na memória e armazenam o resultado em um registrador. (x86).

#Unidade Lógica e Aritmética (ULA)
- O MIPS tem uma ULA de 32 bits
- Para ilustrar sua construção, segue a descrição de uma simples ULA com as seguintes operações:
	-> Soma e subtração em complemento de 2
	-> Operações lógicas and, or e nor
	-> detecção de overflow
	-> detecção de igualdade
	
- Elementos Básicos
	-> Multiplexador
	-> Somador
	
#Instrução slt 
- A instrução slt gera saída 1 se rs < rt, e 0 caso contrário. 
	- Assim, todos os bits, com exceção do bit menos significativo, são fixados em zero.
- O bit menos significativo depende do resultado da comparação.
- Inclui-se a entrada Less.
- Calcula-se este valor subtraindo rs de rt e tomando-se o bit mais significativo (“Sinal”): se rs – rt < 0, rs <rt

#Testando igualdade
- As instruções bne e beq testam se dois valores são iguais ou não
- Para testar igualdade subtrai-se os dois operandos e testa-se se o resultado é zero: A = B se A – B = 0 = R
- Teste: operação NOR entre os bits do resultado => Igual = not(R0 or R1 or ... or R31)






























 
 



