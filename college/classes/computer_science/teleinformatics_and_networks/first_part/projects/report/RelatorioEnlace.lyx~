#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\begin_preamble
\usepackage{algpseudocode}
\end_preamble
\options journal
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding default
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement tbh
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Your Title"
\pdf_author "Your Name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Comparativo de protocolos na Camada de Enlace
\end_layout

\begin_layout Author
Gabriel Martins de Miranda e Guilherme Neves
\end_layout

\begin_layout Abstract
Análise de eficiência entre os protocolos ARQ da camada de enlace.
\end_layout

\begin_layout Keywords
Stop-and-Wait ARQ, Go- Back N ARQ, Selective Repeat ARQ 
\end_layout

\begin_layout Peer Review Title
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Don't add text here!
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
required if you use the document class option 
\family sans
peerreview
\family default
, must otherwise not be used
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introdução 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(2/3 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A camada de enlace é uma das sete camadas do modelo OSI, e também a quarta
 do modelo TCP/IP.
 Ela detecta e, opcionalmente, corrige erros que possam acontecer na camada
 física.
 É responsável por transmitir e receber quadros e também pelo controle de
 fluxo, sendo que opera em velocidades próximas à da luz.
 Na rede ethernet, cada placa de rede possui um endereço físico, que deve
 ser único na rede, chamado MAC.
 
\end_layout

\begin_layout Standard
O serviço básico da camada de enlace é mover um datagrama de camada de rede
 de um nó (roteador ou hospedeiro) até um nó adjacente.
 Todos os seus protocolos operam encapsulando um datagrama dentro de um
 quadro antes de transmiti-lo.
 Diferentes protocolos oferecem diferentes serviços de acesso ao enlace,
 de entrega (confiabilidade, detecção/correção de erros), de controle de
 fluxo e de transmissão (full-duplex ou half-duplex).
 Tais diferenças são devidas à vasta variedade de tipos de enlaces sobre
 os quais os protocolos de enlace devem operar.
 Um enlace ponto a ponto simples tem um único remetente e um único receptor
 comunicando-se por um único fio.
 Um enlace de acesso múltiplo é compartilhado por muitos remetentes e receptores
, o que faz com que um protocolo para um canal de acesso múltiplo tenha
 um protocolo para coordenar o acesso ao enlace.
 Nos casos de ATM e MPLS, o enlace que conecta dois nós adjacentes pode,
 na realidade, constituir uma rede em si e por si próprio.
\end_layout

\begin_layout Standard
Dentre os princípios subjacentes à comunicação por enlace, tem-se técnicas
 de detecção e correção de erros, protocolos de acesso múltiplo, endereçamento
 de camada de enlace e a construção de redes locais ampliadas por hubs e
 comutadores.
 Para a detecção/correção de erros, é possível a adição de bits ao cabeçalho
 de um quadro para detectar e algumas vezes corrigir erros de mudança de
 bits que podem ocorrer quando o quadro é transmitido, seja por esquemas
 simples de paridade ou de soma de verificação, seja por esquemas mais robustos
 de verificação de redundância cíclica.
 Já em se tratando de protocolos de acesso múltiplo, três abordagens são
 amplamente utilizadas para coordenadar o acesso a um canal broadcast, sendo
 elas por divisão de canal (TDM, FDM, CDMA), por acesso aleatório (protocolos
 ALOHA e CSMA) e através de revezamento (polling e passagem de permissão).Alguns
 de seus protocolos são o Ethernet e o PPP.
 No caso de protocolos de detecção e correção de erros da camada de enlace,
 temos os métodos de pedido automático de repetição (ARQ), que serão explicitado
s nas seções seguintes.
\end_layout

\begin_layout Section
Fundamentação teórica 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(4/5 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Stop-and-Wait ARQ, Go- Back N ARQ e Selective Repeat ARQ
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Confiabilidade
\end_layout

\begin_layout Standard
Uma boa definição para entrega confiável é quando um dado é aceito no fim
 de um enlace na mesma ordem transmitida no outro fim, sem perda e sem duplicaçõ
es.
 Isto implica em quatro restrições: sem perda (pelo menos uma cópia de cada
 PDU é mandado), sem duplicações (não mais de uma cópia de um PDU é enviado),
 entrega FIFO (PDUs entregues na ordem original) e o PDU deve ser entregue
 em um período confiável.
 Para suportar confiabilidade, o protocolo implementa um procedimento de
 recuperação de erros.
 Esta confiabilidade deve ser provida em várias camadas do modelo OSI, alguns
 exemplos de protocolos são: Camada de enlace (HDLC), transporte (TCP) e
 aplicação (TFTP).
 Alguns dos maiores problemas encontrados pelos protocolos são: corrupção
 de bits dentro do canal, falhas de temporização resultando em decodificações
 errôneas nos bits recebidos, erros de software na implementação dos protocolos
 e tamanho de buffer insuficiente nos equipamentos.
 
\end_layout

\begin_layout Itemize
Stop-and-Wait-ARQ
\end_layout

\begin_layout Standard
Técnica mais simples de confiabilidade.
 Transmite um Protocol Data Unit (PDU) de informação e então espera por
 uma resposta.
 O receptor intercepta o PDU e então envia um Acknowledgement (ACK) PDU
 se o dado é recebido corretamente, ou um Negative Acknowledgement (NACK)
 se o dado não foi recebido.
 Na prática, o receptor pode não estar apto a identificar se um PDU foi
 recebido, e o transmissor terá de implementar um temporizador para lidar
 com a condição de o receptor não responder.
 Sob transmissão comum, o emissor receberá um ACK para o dado e então começar
 a transmissão do próximo bloco de dados.
 Por um longo enlace, o emissor pode ter de esperar um tempo apreciável
 pela resposta.
 Enquanto espera, o temporizador é dito em estado 
\begin_inset Quotes eld
\end_inset

ocioso
\begin_inset Quotes erd
\end_inset

 e é incapaz de enviar dados.
\end_layout

\begin_layout Standard
Baseia-se em dois caminhos de transmissão (full dulplex ou half duplex).
 Um pequeno delay de processamento deve ser introduzido entre a recepção
 do último byte PDU e a geração do ACK correspondente.
 Quando um PDU é perdido, o receptor não irá normalmente ser capaz de identifica
r a perda, o transmissor então deve ser confiável para detectar a falta
 de resposta.
\end_layout

\begin_layout Itemize
Go-Back-N-ARQ
\end_layout

\begin_layout Standard
Detecta e retransmite I-frames que foram corrompidos devido à erros na camada
 física.
 Para suportá-lo, o protocolo deve numerar cada PDU que é enviado, geralmente
 feito usando a aritmética de módulo.
 O nó local deve manter um buffer de todos os PDUs que foram mandados e
 não receberam ACK ainda, enquanto o receptor deve guardar um registro do
 maior número de PDU que foi corretamente recebido.Para realizar a recuperação
 de frames perdidos, primeiro há o descarte dos PDUs no nó remoto do receptor.
 Em seguida este nó solicita a retransmissão do PDU faltante usando o controle
 de NACK ou REJECT.
 O receptor descarta todos os PDUs que não tem o número do PDU requerido.
 Finalmente ocorre a retransmissão do quadro perdido.
 O controle indica o último PDU recebido com sucesso.
 Isto permite instruir o emissor de onde deve começar a retransmissão de
 PDUs.
 Todos os PDUs fora de sequência são descartados.
 
\end_layout

\begin_layout Standard
Após o recebimento de um PDU de controle pelo nó local, o transmissor volta
 a janela de volta onde a unidade pendente que recebeu no buffer de NACKs.
 Este então retransmite seguido de todos os PDUs sucessivos a este.
 Se a retransmissão falhar, o PDU perdido pode ser enviado através da técnica
 de pooling.
\end_layout

\begin_layout Itemize
Selective-Repeat-ARQ
\end_layout

\begin_layout Standard
É o mais complexo dos que provêm recuperação de erros, entretanto o mais
 eficiente.
 É o empregado pelo protocolo TCP da camada de transporte.
 Assim como no Go Back N, para suportá-lo o protocolo deve numerar cada
 PDU que é mandado, normalmente com módulo.
 O nó local deve também manter um buffer de todos os PDUs que foram mandados
 mas que não foram reconhecidos.
 O receptor no nó remoto mantem um registro do PDU de maior valor que foi
 corretamente recebido.
 Este número corresponde ao último ACK que enviou.
 Ao contrário do Go Back N, o receptor também deve manter um buffer de quadros
 que foram recebidos, mas não reconhecidos.
\end_layout

\begin_layout Standard
A recuperação de um PDU corrompido ocorre em quatro etapas: primeiramente,
 o PDU é descartado no nó remoto do receptor.
 Após isto, o nó remoto requisita retransmissão do PDU faltante usando o
 controle de PDU (chamado Selective Reject), O receptor então armazena todos
 os PDUs fora de sequência em seu buffer até que o faltante seja retransmitido.
 O emissor recebe o pedido de retransmissão e então transmite o quadro perdido.
 Finalmente, o receptor recebe o faltante e todos os subsequentes são tomados
 em ordem do seu buffer.
 A retransmissão feita pelo nó remoto de PDUs corrompidos é feita através
 de um controle indicando o quadro faltante.
 Após o transmissor receber o controle, manda um único PDU do buffer de
 PDUs sem ACK.
 Daqui, o transmissor continua sua transmissão normalmente até novo pedido
 de controle.
 No Selective Repeat, PDUs perdidos também são recuperados através de pooling.
\end_layout

\begin_layout Section
Implementação teórica 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(4/5 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
modelagem do sistema
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ferramenta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
cenários
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O sistema foi modelado na linguagem C, utilizando o sistema operacional
 LINUX.
 Para emular a emissão e recepção de pacotes, tanto quanto os vários casos
 de erros envolvidos, funções foram usadas com estes papéis.
 Para todos os protocolos implementados, foi modelada as funções 
\shape italic
Emissor, Receptor e Canal.
 Todos os protocolos encaminham os bits utilizando um vetor como pacote
 de dados, sendo que a cada iteração este é enviado como argumento para
 a função receptora.
 Dentro do emissor temos os loops referentes ao tipo de protocolo utilizado.
 Para o stop and wait, foram utilizadas estruturas de repetição até que
 um ack fosse recebido.
 No go back n, uma janela deslizante de quatro pacotes de tolerância, sendo
 que em caso de perdas retransmite as últimas informações.
 Por último, o selective repeat guarda os próximos pacotes que de-se enviar
 e espera enquanto não enviar o número pré-definido.
\end_layout

\begin_layout Itemize
Stop-and-Wait-ARQ
\end_layout

\begin_layout Standard
Para o cálculo da eficiência do Stop-and-Wait foi utilizada a fórmula representa
da pela Figure 1, sendo 
\begin_inset ERT
status open

\begin_layout Plain Layout

$nf$
\end_layout

\end_inset

 o número total de bits no frame, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$no$
\end_layout

\end_inset

 o número de bits no header e no CRC, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$t0$
\end_layout

\end_inset

 o tempo total para enviar a informação, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$Pf$
\end_layout

\end_inset

 a probabilidade de ocorrer um erro de transmissão e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$to$/(1 - Pf)
\end_layout

\end_inset

 o tempo médio total gasto por frame.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/1.stop_n_eff.png
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eficiência do Stop-and-Wait-ARQ.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Go-Back-N-ARQ
\end_layout

\begin_layout Standard
Para o caso de eficiência no Go-Back-N-ARQ foi utilizada a fórmula representada
 pela Figure 2, sendo o tempo para mandar um frame 
\begin_inset ERT
status open

\begin_layout Plain Layout

$tf$
\end_layout

\end_inset

 caso o primeiro frame da transmissão seja enviado corretamente ou 
\begin_inset ERT
status open

\begin_layout Plain Layout

$tf + Ws*tf/(1 - Pf)$
\end_layout

\end_inset

 caso contrário.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/2.go_back_eff.png
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eficiência do Go-Back-N-ARQ.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Selective-Repeat-ARQ
\end_layout

\begin_layout Standard
Para a eficiência do Selective-Repeat-ARQ foi utilizada a fórmula representada
 pela Figure 3.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/3.selective_eff.png
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eficiência do Selective-Repeat-ARQ.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um sumário dos cálculos das eficiências dos três protocolos pode ser visto
 na Figure 4.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/4.sumario.png
	width 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparação entre as eficiências dos protocolos ARQ.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Análise
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
execução
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
resultados
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para velocidades mais baixas, o stop and wait mostrou-se mais eficaz devido
 à característica de esperar o ack do receptor, em contrapartida, o tempo
 ocioso para velocidades altas mostrou-se mais alto.
 O go back n mostrou uma taxa de erros menor, uma vez que a cada erro são
 reenviados quatro vezes mais quadros que nos outros protocolos.
 Já o selective repeat mostrou-se mais eficiente em situações onde a taxa
 de erros é média ou alta devido ao fato de não reenviar pacotes já recebidos.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
frames/eficiencia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GBN 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relação entre frames enviados e eficiência dos protocolos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusões
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2 parágrafos
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O presente trabalho foi de grande ajuda para entender o funcionamento dos
 protocolos ARQ da camada de enlace.
 Houve uma maior dificuldade em representar o caráter paralelo dos protocolos,
 em que emissor e receptor trabalham de forma simultânea.
\end_layout

\begin_layout Standard
[0] Wikipedia
\end_layout

\begin_layout Standard
[1] Redes de computadores e a Internet - Kurose - Ross
\end_layout

\begin_layout Standard
[2] ARQ Protocols - Prof.
 Anish Goel (MIT)
\end_layout

\end_body
\end_document
