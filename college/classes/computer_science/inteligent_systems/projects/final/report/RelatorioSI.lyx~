#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\begin_preamble
\usepackage{algpseudocode}
\end_preamble
\options journal
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding default
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement tbh
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Your Title"
\pdf_author "Your Name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Classificador Cascade para Detectar Bola em Competições de Robótica
\end_layout

\begin_layout Author
Gabriel Martins de Miranda e Fernanda Amaral Melo
\end_layout

\begin_layout Keywords
classificador cascade, rastreamento
\end_layout

\begin_layout Peer Review Title
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Don't add text here!
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
required if you use the document class option 
\family sans
peerreview
\family default
, must otherwise not be used
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introdução 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(2/3 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um grande problema em competições de futebol é rastrear a bola.
 O padrão branco e preto é facilmente confundido com as outras entidade
 do campo, como gol e linhas.
 Através de casamento de padrões e aprendizado de máquina, baseado na técnica
 de boosting, é apresentado um método robusto de detecção de bola capaz
 de ser processado num fluxo de vídeo em tempo real.
\end_layout

\begin_layout Section
Fundamentação teórica 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(4/5 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O classificador cascade é um método de aprendizado de máquina baseado em
 features, em que atualmente classificam-se em haar ou lbp, e em estágios,
 o que define seu nome de cascata.
 Sua detecção ocorre de forma binária, ou seja, ou o objeto de interesse
 se encontra na imagem, ou não.
 É treinado a partir de um grande set de imagens positivas ou seja, do objeto,
 e negativas, qualquer imagem em que o objeto definitivamente não esteja
 presente.
 
\end_layout

\begin_layout Standard
O objetivo do classificador é gerar um arquivo capaz de definir um conjunto
 de classificadores fortes em cada estágio do cascade, sendo os classificadores
 fortes a soma ponderada das melhores features do estágio, sendo cada uma
 dessas features um classificador fraco.
\end_layout

\begin_layout Standard
Para sumarizar o funcionamento do algoritmo, é feita uma separação em quatro
 tópicos, features haar, imagens integrais, adaboosting e cascading.
\end_layout

\begin_layout Itemize
Haar features
\begin_inset Newline newline
\end_inset

As features utilizadas são definidas como kernels capazes de detectar caracterís
ticas.
 Quando convolucionados com uma imagem, recebem um valor único definido
 em função da feature utilizada e da posição em que ela se encontra.
 Para cada feature haar, seu valor é dado pelo produto interno entre os
 pixels da feature, sendo so brancos definidos com o valor 1 e os pretos
 com o valor -1, e os pixels da imagem em nível de cinza.
 Em Figure 1 é possível ver a configuração de possíveis features haar utilizadas.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/1-features.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Algumas features utilizadas no haar, com dois, três e quatro retângulos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Em Figure 2 pode-se ver dois resultados de alto valor para duas features
 haar em determinada posição na imagem.
 Cada uma delas representa um classificador fraco.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/2-feature-viola.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Algumas features de alto valor em convolução com uma face.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ainda assim, numa pequena janela 24x24 pixels podem existir mais de 160
 mil features haar.
 Para facilitar o processo de obtenção dos classificadores fracos dentro
 todas as outras, uma abordagem de imagens integraise é usada.
\end_layout

\begin_layout Itemize
Imagens Integrais
\begin_inset Newline newline
\end_inset

Cada pixel na imagem integral é a soma acima e à esquerda na imagem original.
 Este tipo de vizualização da imagem permite rápido cálculo dos valores
 das features haar quando estão na fase de convolução do treinamento\SpecialChar endofsentence

\begin_inset Newline newline
\end_inset

Na figura 3 pode-se ver um exemplo de imagem integral para uma entrada 3x3
 contendo apenas pixels de valor unitário.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/4-integral1.png
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Imagem integral para uma três por três unitária.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Adaboost
\begin_inset Newline newline
\end_inset

Uma técnica muito utilizada em aprendizado de máquina é o boosting, sendo
 comumente utilizada em aprendizado supervisionado e na definição de classificad
ores fortes a partir dos fracos.
 O Adaboost, ou adaptative boosting, é uma variação desta técnica.
 Através dele, é possível encontrar as melhores features haar dentre todas
 as outras cento e sessenta mil features.
 A Figura 4 mostra a seleção das melhores features e a construção de um
 classificador forte a partir delas.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/6-ada1.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/7-ada2.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Seleção das melhores features e construção do classificador.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Cascading
\begin_inset Newline newline
\end_inset

Para realizar uma computação dos classificadores de forma mais rápida e
 eficiente, um modelo de cascata é utilizado.
 Neste modelo, apenas features mais simples são utilizadas nos estágios
 iniciais.
 Com isto, padrões com chance baixa de serem classificadores já são descartados
 com baixo custo computacional.
 Aos classificadores simples que passaram, padrões mais complexos são usados
 a partir destes nos estágios mais avançados.
 Com isto, são usadas features complexas apenas em áreas na imagem com maior
 chance de serem o objeto de interesse.
 Na Figura 5 pode-se ver um fluxograma da etapa de cascading.
 As features que possuem maior chance de serem classificadores passam para
 o estágio do algoritmo seguinte.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/8-cascading.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Etapa de cascading.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pode-se ver um sumário do algoritmo na Figura 6.
 Como entrada, temos um grande set de imagens positivas e negativas.
 O algoritmo é treinado com Adaboost e são selecionadas as melhores features,
 com limiares e pesos bem definidos, formando classificadores fortes.
 Após a definição das features e de suas posições na subjanela, os cálculos
 são usados em imagens de teste para detectar o objeto.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/9-sumario.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sumário do método.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementação teórica 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(4/5 parágrafos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
modelagem do sistema
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ferramenta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
cenários
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diante do método, o principal objetivo é auxiliar um robô de baixo custo
 a rastrear uma bola de futebol oficial em competições.
 Para treinamento do método, foi utilizada a biblioteca OpenCV em sua versão
 2.4.12.
 Com a função opencv_createsamples, temos como entrada uma listagem de todas
 as imagens positivas utilizadas, no caso 1100, sendo que para cada uma
 é definida uma região de interesse, ou seja, a região onde o objeto de
 interesse se encontra.
 Para isto, foi usada a bola de futebol nas mais diversas situações, seja
 parada, se movendo, com baixa e alta luminosidade e nas mais variadas distância
s.
 A única restrição imposta pelo método é que as images tenham o mesmo aspect
 ratio.
 Como negativas, foram usadas 1700 images, sendo que para estas não há restrição.
 Com opencv_traincascade é executado o treinamento em si.
 Para executar o treinamento de forma mais eficiente, habilitou-se o modo
 de utilização do opencv com multi-core, e usando um computador com processador
 i7 de primeira geraçao e 4GB de RAM conseguimos executar o treino em até
 seis horas, tempo bem restrito se comparado à execução comum, que demora
 em média uma semana.
 Ao fim do processo, é gerado um arquivo xml especificando todos os classificado
res e também as diversas opções utilizadas.
 Dentre estas opções, usamos tipo de estágio BOOST, tipo de feature HAAR,
 taxa mínima de acerto em torno de 9,95%.
 Máxima taxa de alarme false em 0.4 e quinze estágios.
 Os últimos parâmetros são para o Adaboost.
 A Figura 7 mostra os robôs utilizados para a competição em cuja bola foi
 treinada.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/10-nao.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Robôs NAO na robocup 2015.
 Antigamente a bola era vermelha.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Análise
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
execução
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
resultados
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para validação do código, fez-se uma métrica de falsos positivos e falsos
 negativos.
 Para o caso de falsos positivos, o algoritmo encontrou uma bola onde na
 verdade não havia bola na imagem.
 Já para os falsos negativos, o método nada achou, porém havia uma bola.
 A Tabela 1 a seguir exemplifica os resultados para um total de 200 imagens
 usadas.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Falso positivo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Falso negativo 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Acerto(%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86,5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Relação entre Falsos positivos e falsos negativos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusões
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2 parágrafos
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Através do uso do algoritmo a detecção de bolas melhorou de forma significativa,
 porém ainda é um problema o fato de o processamento dentro do robô ser
 muito lento, já que os resultados foram testados em nossas máquinas com
 processadores muito mais potentes que os usados pelo nao, que usa um Intel
 Atom de apenas um núcleo.
 Sendo assim, diversas otimizações são necessárias para tornar o código
 mais rápido e robusto.
\end_layout

\begin_layout Standard
[0] 
\end_layout

\end_body
\end_document
